# PHP:Основы
## Основные конструкции языка
### Типы данных и переменные
```php

# Числа

$one = 1;
$number = -100;

# Строки

$str1 = 'i am a string';
$str2 = 'i am a string too';

# Логические значения

$yes = true;
$no = false;

```

### Преобразование типов

```php

# Числа

$one = (int) '234';
$two = (string) 34;

```

### Операции

```php

// Арифметические операции
1 + 5 -8 * 6 / 2 ** 3 % 4;

// Логические операции
true || false && !true

// Создание переменных
$str = 'i am a string';

// Обращение к символам строки
$str[0]; // i
print_r("{$str}"); // => i am a string
print_r($str); // => i am a string

```

### Условные конструкции

```php

if ($a > $b) {
  echo 'а больше, чем b';
} elseif ($a == $b) {
  echo 'a равен b';
} else {
  echo 'a меньше, чем b';
}

$result = $a > $b ? 'yes' : 'no';

switch ($i) {
    case 0:
        echo "i равно 0";
        break;
    case 1:
        echo "i равно 1";
        break;
    case 2:
        echo "i равно 2";
        break;
    default:
       echo "i не равно 0, 1 или 2";
}

```

### Циклы

```php

$i = 1;
while ($i <= 10) {
    echo $i++;
}

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

```

### Функции

```php

// Определение
function get($string, $index = 0)
{
    return $string[$index];
}

// Вызов
get('lala', 3);

```


## Отладка
Вывод ошибки делится на две части: непосредственно сообщение с ошибкой и бектрейс (иногда говорят "стектрейс")  
* это список всех вызовоз функций от запуска программы вплоть до того места, где произошла ошибка. Бектрейс - очень важный инструмент, который позволяет увидеть то, как выполнялась ваша программа, и какие функции вызывались. Отладка всегда сводится к двум вещам:
1) перевести сообщение об ошибке
2) найти в бектрейсе то место в своем коде, после которого произошла ошибка.  
Каждая строчка в бектрейсе представляет собой указание на файл и строчку, в которой была вызвана соответствующая функция. Бектрейс называется *back*, потому, что вывод строк идет в обратном порядке. Наверху находится последний вызов, внизу - первый. В рамках одного бектрейса возможны (и часто встречаются), ситуации, когда часть функций вызывается где-то в библиотеках, которое вы не писали, но используете, а часть - в вашем коде.
### Типы ошибок
#### Синтаксические
Они связаны с тем, что код записан неверно, например забыта точка с запятой в конце инструкции. В выводе таких ошибок всегда присутствуют фразы *parse error* и *syntax error*. Для и исправления нужно открыть то место к коде, на которое указывает ошибка, и внимательно не него посмотреть.
``` PHP Parse error: syntax error, unexpected '}' in /usr/src/app/src/Users.php on line 7```
#### Ошибки программирования:
* Вызов несуществующей функции
* Использование необъявленной переменной
* Передача неверных аргументов в функции, например, аргументов, имеющих неправильный тип.  
Они возникают в результате неправильной логики или раннего вызова.
#### Логические
В подавляющем большинстве случаев проблема кроется в неверной логике
### Отладка
Общая идея отладки сводится к анализу того, как меняются значения переменных в процессе работы кода.  
Один из способов отслеживать значения переменных во время выполнения кода связан с использованием отладчиков.  
Один из способов отслеживать значения переменных во время выполнения кода связан с использованием отладчиков. Отладчики интегрируются с популярными редакторами и позволяют визуально выполнить код по шагам, отслеживания любые изменения.  (гуглить по запросу: xdebug php <название редактора>).  

   Знак операции, такой как + это **оператор**, а числа это **операнды**. Операции, которые требуют наличия двух операндов, называются **бинарными**. Операции бывают не только бинарными, но и *унарными* (с одним операндом) и даже *тернарными* (с тремя операндами)!  
**Коммутативный закон** - от перемены мест слагаемых сумма не меняется.

## Линтер  
[**PSR-1:** Базовый стандарт написания кода](https://www.php-fig.org/psr/psr-1/) - Это набор правил, определяющих как следует оформлять программный код.  
[**PSR-2:** Руководство по оформлению кода](https://www.php-fig.org/psr/psr-2/) - Во-первых, этот стандарт требует выполнения правил PSR-1. Во-вторых, он добавляет множество новых требований.  
Повсеместно используемым линтером в PHP является [PHP_CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer).


## Типы данных
1. Примитивные типы - простые типы, они встроены в сам язык PHP.
   1. Строка - описывает набор символов (иными словами текст).
   2. Целые числа
   3. Рациональные числа
*Тип данных опеределяет, что можно делать с элеменатми конкретного множества элементов.*


PHP - это язык со слабой типизацией. Во многиз ситуациях лучше делать преобразование явно, используя специальный синтаксис.

## Переменные
**Переменная** - способ сохранить информацию и дать ей имя для последуюзщего использования в коде.
Для имени переменной испоьзуется любой набор допустимых символов, к которому относятся буквы английского алфавита, цифры, знак _. При этом цифру нельзя ставить вначале. Имена переменных регистрозависимы. Количество создаваемых переменных никак не ограничено. Переменные принято создавать как можно ближе к тому месту где они используются.

### Именование переменных
1. kebab-case
2. snake_case
3. CamelCase  
В PHP используется *CamelCase* и его вариация *lowerCamelCase*, при котором первая буква первого слова — строчная. Именно **lowerCamelCase применяется для переменных**.  
#### Ошибки при работе с переменными
Переменная должна быть объявлена до ее использования.  
Все что справа от знака равно выражение. Любая строка выражение. Конкатенация строк - тоже выражение. Когда интерпретатор видит выражение, он обрабатывает его и генерирует результат - **значение выражения**. Правила построения кода таковы, что в тех метсах где, ожидается выражение, можно поставить любое вычисление (как математическое, так и строковое).
> Любая переменная может быть частью любого вывражения. В момент вычисления имени переменнной подставляется её значение.

#### Константы
1. Ключевое слово *const* (знак доллара не нужен).
2. Принято именовать буквами в верхнем регистре с _в качестве разделителя.

**[Предопределеные константы](https://www.php.net/manual/ru/reserved.constants.php)**. В PHP очень много **встроенных** констант. Некоторые из них:
- **PHP_VERSION** - текущая версия PHP
- **PHP_MAXPATHLEN** - максимальная разрешенная длина имени файла
- **PHP_INT_MAX** - максимальное возможное значение чисел (integer)

**Магические константы** - они не очень постоянные, но их изменения четко реглпментированы.
- Невозможно определить самомму, можно пользоваться только существующими
- Начинаются и заканчиваются символами "__"(два подчеркивания)
- Имеют одно и то же значение в пределах определенной части программы  
Например:
* __LINE__ - содержит текущую строку файла, в котором она используется
* __FILE__ - путь до текущего файла
* __DIR__ - путь до дериктории, в которой находится текущий файл

**Интерполяция** - способ соединения строк через вставку значений переменных в строку-шаблон с помощью фигурных скобок. Например, "Hi, {$name}!".  
В одной строке количество блоков с фигурными скобками не ограничено.

#### Извлечение символов из строки
Осущестляется с помощью *квадратных скобок с цифрой* - это специальный оператор извлечения строки. Эта цифра называется **индексом** - позицией символа внутри строки. Индексы начинаются с **0**.  *Отрицательные индексы* - обращение с символам начиная с конца строки. В отличие от прямой индексации, обратный отсчет идет от **-1**.  
Индексом м.б. также значения переменной. ($index = 0).  


**Herecod** - это использование herecod-синтаксиса: <<<. После этого оператора необходимо указать идентификатор, а затем перевод строки. Такой способ удобен для задания длинных строк, внутри которых встречаются и переводы строк, и разнотипные кавычки. Не нужно экранировать одинарные ' и двойные " кавычки.


## Функции
### Функции и их вызов
Функция - операция, способная принимать данные и возвращать результат.
Аргумент - информация, которую функция получает при вызове.
Вызов функции всегда обозначается скобками (), идущими сразу за именем фунции. В скобках может быть любое количество аргументов (часто говорят параметр), а иногда - вообще ни одного.  
> Любая функция возвращает всегда только одно значение. Это ограничение существует на уровне языка и не может быть нарушено.
**Сигнатура функции** — формальное описание типов аргументов и типа возвращаемого значения функции.


**Стандартная библиотека** - набор полезных функций.
*Советы о том, как узнавать о новых функциях*:
1. Всегда чётко отслеживайте, с чем вы сейчас работаете (какой тип данных). Например, для работы со строками нужно изучать строковые функции.
2. Периодически открывать раздел со стандартными функциями по изучаемой тематике и пробегаться по ним, изучая сигнатуры и способы использования.  
3. Чаще читайте чужой код, особенно код библиотек, которые вы используете.  
> Особенность функций PHP из стандартной библиотеки в том, что они доступны *глобально*.
**Аргумент по умолчанию** - необязательный аргумент функции.
**Выражение** - это код, который при выполнении программы превращается в значение.  
> **!Вызов функции тоже выражение**. А значит мы можем положить вызов функции в вызов функции.  
> Все что работает, как выражение, может быть использовано в других выражениях, а также во всех местах, где на вход ожидаются выражения.  
Если вычисление совсем простое и неглубокое (не больше одного вложения функции), то смело можно вкладывать вызов в вызов. В остальных ситуациях предпочтительно разбивать вызовы на промежуточные вычисления.
- Во первых, промежуточные переменные своими названиями отражают суть операций.
- Во вторых, такой код легче отлаживать, а промежуточные данные проще исследовать.
- В третьих, глубокие вложенные вызовы сложно читать.  
PHP является языком с **жадными вычислениями**. PHP пытается сначала вычислить максимально глубокий уровень вызова, затем менее глубокий и так далее.  
**Побочный эффект** - действие, которое изменяет внешнее окружение (среду выполнения). Например, вывод на экран или отправка письма.


### Создание (определение) функции
Код в котором создается функция, называетя **опеределением функции**.
**Аргумент должен быть переменной**, иначе он не сможет быть аргументом, то есть чем-то, что принимает значение при вызове.  
> Если нужна какая-то информация в функции, и заранее известно, какая именно, то аргумент для этого не нужен - достаточно создать переменную в самом теле.  
Символ `;` ставится в конце выражений. **Определение функции - не выражение, а инструкция** (указание интерпретатору). Соответственно, мы не можем его использовать в составе других выражений и ему не нужна `;` в конце.
**Параметры по умолчанию**. Аргументы могут быть необязательными. У такого аргумента есть значение по умолчанию. Этот фрагмент `= какое_то_значение` делает аргумент необязательным, и задаёт ему значение по умолчанию. Аргументов по умолчанию м.б. любое количество, но все они должны быть в конце списка аргументов.  

#### Именование
Стиль именования переменных: lowerCamelCase.  
**Функция - действие**, вызов функции всегда подобен указанию "схожи", "возьми", "напечатай","положи" и так далее.  
**Переменная - сущность**, поэтому мы используем существительные.  
> Следующая структура: функция - глагол, переменная - существительное.

#### Документация
[Документация PHP досутпна на русском языке](http://php.net/manual/ru/)  
Основной раздел, к которому программисты возвращаются постоянно — [справочник функций языка](https://www.php.net/manual/ru/funcref.php).
1. Во-первых этих функций много и невозможно запомнить все.
2. Во-вторых, в PHP, особенно стоит проблема несогласованности параметров и возвращаемых значений функций.  
> Для описания функции используется собственная нотация, это не код PHP, а только лишь описание сигнатуры функции.


## Логика
### Логический тип
Список оперций сравнения:
- `<` меньше
- `<=` меньше или равно
- `>` больше
- `>=` больше или равно
- `===` равно
- `!==` не равно  
Логическая операция - это выражение, и его результат - специальное значение `true` ("истина") или `false` ("ложь"). Это тип данных bool. Наряду со строками (string) и целыми рациональными числами, **тип _bool_ - это один из примитивных типов данных в PHP**.  


### Предикаты
Предикат отвечает на утвердительный вопрос "да" или "нет", возвращая значение типа bool. В php предикаты как правило начинаются с префикса `is` или `has`:
- `isInfant` - "младенец ли?"
- `hasChildren` - "есть ли деньги?"
- `isEmpty` - "пустой ли?"
- `hasError` - "есть ли ошибки?"  
> Фукнция может считаться предикатом, **только** если она возвращает bool.


### Комбинирование операций и функций
Логические операции - это выражения. **Логические операции можно комбинировать с другими выражениями**.  
Для проверки четности числа, в программировании используют проверку остатка от деления на 2: если остаток 0, то число было четным, если остаток не 0, то число было нечётным.  
Оператор `%` вычисляет остаток от деления.  **Приоритет арифметических операций выше логических**.

#### Логические операторы  
`&&` - означает "И" (Конъюкция). Всё выражение считается истинным, только если истинен каждый операнд - каждое из составных выражений. Иными словами, `&&` означает "и то, и другое". Приоритет этого оператора ниже, чем приоритет операторов сравнения.  
`||` - "ИЛИ" (дизъюнкция). Он означает ""или то, или другое, или оба. Когда одновременно встречаются `&&` и `||`, то приоритет лучше задавать скобками.  
`!` - унарный оператор "отрицание". Необходимо просто добавить `!` слева от вызова функции. 


##### Условная конструкция  
`if` - инструкция. В скобках ей передается выражение-предикат, а затем описывается блок кода в фигурных скобках. Этот **блок кода будет выполнен, только если предикат - истина.** `if ($x > 10) { ... }` Если предикат - ложь, то блок кода в фигурных скобках пропускается, и функция продолжает свое выполнение дальше.  
`else` - переводится "иначе", "в ином случае". Этот блок выполнится, только если условие в `if` - ложь.
`elseif` - это «если не выполнено предыдущее условие, но выполнено текущее».  

**Тернарный оператор** - конструкция которая по своему дейтсвию аналогична конструкции *if-else*, но при этом является выражением.  
**Оператор Элвис** - `?:` - бинарный оператор, который возвоащает первый операнд если он истинен, и второй в ином случае.

**Слабая типизация**  
В PHP есть два простых правила преобразования:  
- `0`, ` `, `null` превращаются в `false`
- всё остальное превращается в `true`  
> Это работает и в обратную сторону.

## Циклы
### While
Цикл While — инструкция для повторения кода, пока удовлетворяется какое-либо условие. Состоит из 3 элементов:
- Ключевое слово *while*
- Предикат в скобках после *while*
- Блок кода в фигурных скобках (тело цикла)  
Каждое выполнение тела называетя **итерацией**.  
> Индекс последнего элемента всегда меньше на единицу размера строки.  
### Пограничные случаи
Ошибка в пограничных случаях - самая частая причина логических ошибок в программах. Часто причина в слабой типизации PHP.  
**Пограничные случаи** которые стоит учитывать в работе со строками:
- отрицательная длина извлекаемой подстроки
- отрицательный заданный индекс
- заданный индекс выходит за границу всей строки
- длина подстроки в сумме с задынным индексом выходит за границу всей строки  
В реализации функции каждый пограничный случай будет отдельным кускод кода, скорее всего реализованным с помощью `if`.  


**Синтаксический сахар**  
```php
* $a = $a + 1 → $a += 1
* $a = $a - 1 → $a -= 1
* $a = $a * 2 → $a *= 2
* $a = $a / 1 → $a /= 1
* $a = $a . 'bla' → $a .= 'bla' 
```


**Инкремент `++` и декремент `--`** - эти унарные операции увеличивают и уменьшают на единицу число, записанное в переменную.  
> В отличие от всех остальных операций, которые не имеют побочных эффектов и просто возвращают новое значение, инкремент и дикремент не только возвращают значение, но и **изменяют** значение переменной.  
*Постфиксная формы* - сначала происходит возврат, а потом изменение переменной.  
- `$i++` возвращает `i` и увеличивает его на 1
- `$i--` возвращает `i` и уменьшает его на 1  
*Префиксная форма* - сначала происходит изменение переменной, а потом возврат.
- `++$i` увеличивает `i` на 1 и возвращает новое значение
- `--$i` уменьшает `i` на 1 и возвращает новое значение  
*Рекомендации по использованию*:
- никогда не мешайте в рамках одного выражения операции/функции без побочных эффектов с операциями/функциями, обладающими побочные эффекты.
- используйте инкремент и дикремент только там, где нет разницы между префиксным и постфиксным вариантом: отдельно от всего, на свое собственной строчке кода.


**Возврат из циклов**. Работа с циклами обычно сводится к двум сценариям:
- 1. Накопление результата во время итераций и работа с ним после цикла (переворот строки как раз относится к такому варианту).
- 2. Выполнение цикла до достижения необходимого результат и выход (например, задача поиска простых чисел (простое число - это число которое делится без остатка только на себя и на единицу)). 


**Цикл For**
```php  
for (счётчик; предикат; изменение счётчиика) {
   // тело цикла
}

// например  
for ($index; $index >= 0; $index--) {
   // ...
}  
```  
Можно читать так: "цикл с индексом `$index` повторяется пока `$index >= 0` и после каждого шага уменьшает `$index` на 1".  
В определении цикла `for` есть:
1. начальное значение счетчика
2. предикат-условие повторения циклов
3. описание того, как счётчик меняется после каждого шага  
В остальном принцип работы точно такой же, как у цикла `while`.


> Цикл `while` идеален для ситуаций, когда количество итераций неизвество заранее, например, при поиске простого цисла.  
>> Когда Количество итераций извество, предпчтительнее использовать цикл `for`.


## Строки
### Юникод
Юникод - программа хранится в памяти компьютера в виде последовательности нулей и единиц. Для работы с многобайтовыми кодировками в язык добавили отдельное *расширение по работе с многобайтовыми строками*, которое по большей части добавляет множество функций для работы со строками, с той лишь разницейЮ что каждая функция из них имеет префикс `mb_` (multibyte).


### Локализация
В каждой стране есть свои особенности по способу записи, сравнению и другим аспектам. Эти особенности не обязательно привязаны к целой стране. Внутри одной страны может быть множество дополнительных разделений. Каждый такой набор называют **локалью**, а процесс адаптации к особенностям конкретной локали - **локализацией**.  
В PHP для управления локалью используется функция `setlocate`. Эта функцтия настраивает локаль глобально. То есть ее вызов влияет на все последующие функции, опирающиеся на локализацию.  
`string setlocale ( int $category , string $locale [, string $... ] )`  
Первым параметром эта функция принимает название категории (как константу), к которой нужно применить локаль, передающуюся в параметрах дальше.  
* `LC_ALL` - все нижеперечисленное
* `LC-COLLATE` - функции сравнения строк, см. `strcoll()`
* `LC_CTYPE` - функции преобразования и классификации строк, например `strtoupper()`
* `LC_MONETARY` - для функции `localeconv()`
* `LC_NUMERIC` - задает символ десятичного разделения (см. также `localeconv()`)
* `LC_TIME` - форматирование даты/времени функцией `strftime()`


#### Поиск стартовой позиции
В PHP такой функции нет, и её имитируют с помощью функции `mb_strpos`. Эта функция ищет позицию первого вхождения одной строки в другую.


#### Время
Основные часы компьютера - аппаратные, они живут самостоятельной жизнью и имеют свою собственную батарею. При включении компьютер считвапет данные этих часов, записывает к себе в память и начинает самостоятельно отсчитывать время. Эти часы называют системными. Любое изменение системных часов влияет и на аппаратные.  
В большинстве операционных систем системное время представляется в формате Unix time. Оно определяется как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года (четверг); время с этого момента называют "эрой Unix" (Unix Epoch). Unix-время представлено целым числом, которое увеличивается с каждой прошедшей секундой без необходимости вычислений для определения года, месяца, дня часа или минтуы для удобства восприятия человеком.  
Конкретная дата в формате Unix time называется timestapm (временной штамп). Например, для получения текущего timestamp в PHP используется функция `time`.


#### Date
Одна из главных функций по работе с датами в PHP - `date`. Она конвертирует timestamp в человекочитаемый формат. Первым параметром в эту функцию передается описание формата даты, которое устроено по похожему принципу как и форматы для функции `sprintf`. `date` по умолчанию использует текущее время. Но если нужно, ей можно передать конкретный timestamp.  
`return date('d/m/Y', $timestamp);`.  
**mktime** - функция генерирует timestamp по информации о времени: секундах, часах, минутах и дате.  
`int mktime ([ int $hour = date("H") [, int $minute = date("i") [, int $second = date("s") [, int $month = date("n") [, int $day = date("j") [, int $year = date("Y") ]]]]]] )`.  
`mktime` - многословная функция, каждая часть даты и времени передается как отдельный параметр.  


#### Часовые пояса (тайм зоны)
Одна из самых сложных деталей при работе с датами - часовые пояса (time zones). Вся земля делится на 24 часовых пояса, так что в соседних поясах время чаще всего отличается на час. Нулевым временем считается *всемирное координрованное время* (UTC). Часовые пояса вокруг земного шара выражаются как положительное или отрицательное смещение от UTC. Например в Москве тайм зона +3.  
Главное правило при работе с датами - хранение и сравнение должно происходить в UTC формате. А вот выводить даты лучше в той зоне, в которой живет пользователь.  
Проверить текущую зону можно функцией `date_default_timezone_get()`.  
Установить зону функцией `date_default_timezone_set()`.  
[Список поддерживаемых временных зон в PHP](https://www.php.net/manual/ru/timezones.php).


**rand** - функция которая генерирует и возвращает случайное число.
** - оператор возведения в степень.


**Определения**
1. *Инструкция (statement)* - Код на PHP — это набор инструкций, разделенных (чаще всего) символом ;.
2. *Parse error (ошибка парсинга)* - тип ошибок в PHP, возникающих при наличии синтаксических ошибок в коде.
3. *Оператор* - специальный символ, создающий операцию.  
    Операции бывают не только *бинарными*, но и *унарными* (с одним операндом) и даже *тернарными* (с тремя операндами)!
4. *Операнд* - объект, который участвует в операции.
5. *Коммутативность* — свойство операции, когда изменения порядка операндов не влияет на результат.
6. *Экранирующая последовательность* - специальная комбинация символов в тексте (\n).
7. *Конкатенация* - склеивание строк.
8. *Стандарт кодирования* - набор синтаксических и стилистических правил написания кода.

**Ошибки**
1. *Undefined variable* - это ошибка обращения, она означает, что в коде используется имя (говорят идентификатор), который не определен.
2. *PHP Warning: pow() expects exactly 2 parameters, 0 given in php shell code on line 1* - функция ожидает 2 параметра, а вы вызвали её без параметров.
3. PHP Warning: A non-numeric value encountered in php shell code on line 1 - передаваемы параметр всегда число.
