![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Typescript_logo_2020.svg/160px-Typescript_logo_2020.svg.png)
# [TypeScript Definitive Guide](https://typescript-definitive-guide.ru/)
> Книга и документация в одном

---
Общее

---
## Что такое TS
### Определение
> Язык программирования со статической типизацией, расширяющий возможности языка JS.

TS компилируется в JS, кот. в свою очередь можно запускать как на клиентской стороне (браузер), так и на серверной (nodejs). Компилятор TS мультиплатформенный и распространяется по лицензии Apache.
### История TS
Разработчиком языка явл. Андерс Хейлсберг, также создавший языки Turbo Pascal, Delphi, C#.
### Для чего нужен
Прежде всего TS предназначен для выявления ошибок на этапе компиляции, а не на этапе выполнения. Кроме того за счет системы типов, разработчики получают подсказки и переходы по коду, избавляет от необходимости комментировать код, а также позволяет выявить проблемы с архитектурой приложения на ранних этапах.  
Компилятор TS также отлично справляется с динамическим кодом JS включенным в свою типизированную среду.
### Зачем разработчику
> TS в значительной мере сокращает время на устранение ошибок и багов, большинство из которых даже не возникнут при написании кода на TS.

Помимо этого TS позволяет писать более выраженный и читаемый код, хорошо описывающий предметную область, за счет чего архитектура приложения становится более выраженной. А также неявно повышает уровень профессионализма разработчиков.  
Всё это в совокупности снижает время разработки приложения.

---
Экскурс в типизацию

---
## Вступление
> Типизация не расширяет возможности разработчиков, она их ограничивает.  

Любой разработчик вовлеченный в разработку должен знать тонкости типизации языков чтобы уметь сделать правильное решение при выборе языка для решения задачи.  
Вопросы связанный непосредтсвенно с самой типизацией:
- Система типов
- Тип данных
- Типы значение
- Ссылочные типы
- Явные/неявные преобразования
- Типизация
- Типизированные/нетипизированные языки
- Статическая/динамическая типизация
- Сильная/слабая типизация
- Явная/неявная типизация
- Вывод типов
- Совместимость типов
## Система типов, тип данных, значимые и ссылочные типы
> Типизация не расширяет возможностей разработчиков, она их ограничивает.

В зависимости от среды выполнения операции над данными могут быть ограничены некими правилами. В роли конкретного вида данных выступает тип данных.  
Среда выполнения в кот. отсутствует классификация данных и ограничения на операции над ними, называется нетипизированный. В обратном случае среда выполнения будет называться типизированной.  
В основе любой типизированной среды выполнения лежит система типов.
### Система типов
> Это совокупность правил назначающих конструкциям составляющим программу свойства именуемую типами.  

Обычно это переменные, объекты, функции с её параметрами и возвращаемым значением.  
В основе любого языка лежит базисная система типов. К ним относятся такие, как: `byte`, `int`, `string`, `boolean`, `object` и подобные. На их основе можно определять типы более высокого порядка.
### Тип данных (тип)
> Это характеристика определяющая множество значений и операций, кот. м.б. выполннены над этими данными.  

Тип может хранить информацию о данных, к кот. относятся поля, свойства и другие структуры языка, а также о том в каком месте будет выделяться память на её выполнение; в каких операциях может участвовать данный тип.  
Типы данных делятся на 2 вида:
- типы значения (_value type_) - хранят значение - при операции присваивания значения данные копируются в памяти
- ссылочные типы (_reference type_) - хранят ссылку на значение - при операции присваивания значения копируется ссылка на данные
### Тип данных, передающийся по значению (примитивный тип)
Когда переменная, ассоциированная со значением принадлежащим к значимому типу участвует в операции присвоения, операнд из левой части будет ассоциирован не со значением правого операнда, а с его копией. Значение будет дублировано в памяти и переменные будут ассоциированы с разными значениями-участками памяти.
### Тип данных, передающийся по ссылке
Если переменная ассоциированная со ссылочным типом данных участвует в операции присваивания, операнду из левой части будет присвоена ссылна на значение, с кот. ассоциирован операнд из правой части. Обе переменные будут ассоциированы с одним и тем же и значением-участком памяти. Если изменить значение любой ссылочной переменной, изменения затронут все переменные ассоциированные с этим значением-участком памяти.
## Связывание, типизация, вывод типов
> Как компилятор определяет принадлежность элементов кода к конкретным типам, что подразумевает под типизацией и какая польза от вывода типов.  

### Обработка кода компилятором
Детали зависят от конкретного языка программирования, но общим явл. то, что компилятор или интерпретатор должен построить понятную ему модель на основе синтаксиса языка. Построение модели делится на 3 этапа анализа: _лексический_, _синтаксический_, _семантический_.
### Лексический анализ (токенизация - tokenizing)
> Лексема - это допустимая последовательность символов.

Исходный код разбивается на лексемы, пробелы и комментарии удаляются.  
`var n = 100 + 2 * 3;` - этот код будет разбит на 9 лексем: `var`, `n`, `=`, `100`, `+`, `2`, `*`, `3`, `;`.
### Синтаксически анализ (разбор - parser)
> Строится дерево разбора путем определения последовательности лексем.  

`var n = 100 + 2 * 3;` - порядок операция вычисления изменен из-за присутствия в нем оператора умножения.  
Именно на данном этапе определяется правильная последовательность.
### Семантический анализ
> Устанавливается семантика (смысл) построенного на предыдущем шаге дерева разбора.  

В зависимости от среды выполнения, может осуществляться привязка идентификаторов к типу данных, проверка совместимости, вычесление типов выражений.  
Независимо какая структура будет получена на данном этапе, все конструкции получат связь с типами данных, которым они принадлежат (произойдет связывание).
### Связывание (binding)
Это операция ассоциирования конструкций нуждающихся в аннотации типа с типами данных к кот. они принадлежат.
### Типизация
Это процесс установления принадлежности результата выражения к типу данных с последующим связыванием его с объектом данных.
### Вывод типов (type interface)
Это возможность компилятора (интерпретатора) определять тип данных, анализирую выражение.  
Для переменной не имеющей явной аннотации типа, компилятор выведет тип на основе результата.
```typescript
// так разработчик видит
var n = 5 + 5; // так видит компилятор var n: number = 5 + 5;
```
## Преобразование типов (type conversion, typecasting)
> Типы относящиеся к одной категории можно конвертировать в друг друга.  

Это процесс заключающийся в преобразовании значения одного типа в значение другого типа.
Преобразования типов делятся на _явные_ и _неявные_ преобразования.
### Неявные преобразования
> Не требуют никаких языковых конструкций и не приводят к потере данных.

Пример преобразования значения типа `int` в тип `double`. Являясь 64-битным вещественным типом, `double` может хранить любое значение 32-битного целочисленного типа `int`. Преобразование `int` в `double` не приводит к потере данных, так как 32-битное значение умещается в 64 битах.
### Явные преобразования
> Для ясности часто называют приведением типов.  

Происходят при участии разработчика и требуют указания языковых конструкций, называемых операторами приведения.
Данное приведение типов требуется тогда, когда в процессе преобразования данные м.б. утрачены или процесс может завершиться с ошибкой.  
Примером служит преобразование типа `double`, используемого для хранения 64-битных значений с плавающей запятой, к целочисленному типу `int`.
## Типизированные (typed) и нетипизированные (untyped) языки программирования
### Нетипизированные языки
Или _безтиповые_ языки как правило очень старые и низкоуровневые языки на кот. программы явл. набором машинных команд. Позволяют производить любые операции над любыми данными, кот. представлены в них как цепочки бит производной длины.
### Типизированные языки
В основу всех современных языков легло такое понятие как система типов. По видам типизации делятся:
- статически и динамически типизированные
- сильно и слабо типизированные
- явно и неявно типизированные
## Статическая и динамическая типизация
> Контроль типов уст. принадлежность типов каждого операнда, а также проверяет его на совместимость с оператором, участвующим в операции.

Этап на кот. происходит контроль типов определяет вид типизации. Контроль типов, кот. происходит на этапе компиляции наз-ся _статическим контролем типов_ или __статической типизацией__.  Контроль кот. происходит на этапе выполнения программы, наз-ся _динамическим контролем типов_ или __динамической типизацией__.
### Статическая типизация (Static Typing)
> Обуславливается тем, что нуждающаяся в аннотации типа конструкция связывается с типом данных в момент объявления в момент объявления на этапе компиляции и связь остается неизменна.

Еще до того как программа будет запущена, компилятор осуществляет проверку совместимости типов учавствующих в различных операциях. Такая программа обладает большей производительностью, т.к. большая часть проверок отсутсвует во время выполнения.  
Повышается семантическая привлекательность кода делая его более читабельным.  
Редактор кода способен выводить вспомогательную информацию.
### Динамическая типизация (Dynamic Typing)
> Обусловлена тем, что нуждающаяся в аннотации типа конструкция, связывается с типом данных на этапе выполнения программы в момент присвоения значения и связь м.б. изменена.

Тип данных м.б. определен только на основании вычесленного результата выражения. При этом операция присвоения значения может изменить тип данных с кот. она была ранее свзяна.  
В языках со статической типизацией есть возможность динамического связывания.
## Сильная и слабая типизация
> Неверные синонимы - _строгая_ и _нестрогая_ типизация. Произошли в результате неверного перевода терминов _strongly typed_ и _weakly typed_, что дословно переводятся как _сильно типизированные_ и _слабо типизированные_.
### Сильная типизация (strongly typed)
Сильная типизация не разрешает выполнение выражений с несовместимыми типами и не выполняет неявное преобразование там, где требуется выполнить преобразование явно.  
Не позволит такие операции, как умножение числа на массив и не выполнит неявного преобразования объекта к строке.  
При операциях способных привести к потере или порче данных возникнет ошибка.
### Слабая типизация (weakly typed)
Разрешает выполнение выражений с любыми типами и самостоятельно выполняет неявное преобразование.  
Например, при сложении строки и объекта объект будет неявно приведен к значению возвращаемому объектом из метода `toString()`, т.е. строке.  
Из-за чего в языках со слабой типизацией высока вероятность появления трудно выявляемых багов, когда программа получает данные ожидаемого типа, но непредсказуемого значения.
## Явная и неявнвя типизация (explicit typing)
### Явная типизация
Явная типизация предполагает что указание принадлежности языковых конструкций к конкретным типам возлагается на разработчиков.  
Если бы не явно указанные типы параметров и возвращаемого типа, разработчикам пришлось сильно больше времени потратить на то чтобы догадаться с чем им предстоит работать.
### Неявная типизация
Неявная типизация не требудет от разрботчика явного указания принадлежности языковых конструкций к конкретным типам, а определение типов возлагается на интерпретатор или компилятор.
## Совместимость типов на основе вида типизации
Каждый раз при присваивании значения компилятор подвергает его проверке на совместимость с ожидаемым типом.
### Совместимость типов (Types Compatibility)
> Это совокупность правил на основе кот. программа, анализирую 2 типа принимает решение о возможности одного типа заменить другой, т.о. чтобы не нарушить выполнение программы.
> > Это механизм по кот. происходить сопоставление типов.

Один из таких механизмов - типизация. Можно выделить несколько групп, кот. составляют 3 вида типизации - _номинативную_, _структурную_ и _утиную_.  
### Номинативная типизация (nominative typing)
Устанавливает совместимость типов основываясь на идентификаторах типов (ссылках).  
Компилятор проверяет иерархию типов на признаки наследования и реализацию интерфейсов.  
Присуща искл. статически типизированным языкам.
### Структурная типизация (structural typing)
Это принцип определяющий совместимость типов, основываясь не на иерархии наследования или явной реализации интерфесов, а на их описании. Компилятор считает типы совместимыми, если сопостоялемый тип имеет все признаки типа с кот. сопостоляется. Чтобы быть совместимым, сопостояляемый тип должен иметь те же ключи, с теми же типами, что и тип, с кот. происходит сопоставление.  
Структурная типизация присуща языкам с явной типизацией.
### Утиная типизация (duck typing)
Ничем не отличаетя от структурной типизации за искл. того что присуща языкам с динамическим связыванием (типизацией).
## Совместимость типов на основе вариативности
Кроме того что совместимость типов зависит от вида типизации, он также может зависеть от такого механизма как вариативность.
### Вариативность
> Это механизм переноса иерархии наследования на производные от них типы. Это не означает связанные отношением наследования, скорее, определяемые теми типами с кот. переносится наследование.

В основе системы типов м.б. заложены след. виды вариативности - ковариативность, контвариативность, инвариативность и бивариативность.
### Иерархия наследования
Это дерево с расположенным вверху _корнем_ или самым _базовым типом_ (менее конкретный тип), ниже кот. распологаются его подтипы (менее конкретные типы).  
Преобразование подтипа к базовому типу называется _восходящее преобразование_ (upcasting). И наоборот, _нисходящее приведение_ (downcasting).  
Отношение м-у _супертипом_ и его _подтипом_ описывается как отношение _родитель-ребенок_ (parent-child). Отношение м-у родителем типа и его ребенком описываются как _предок-потомок_ (ancestor-descendant).  
При логическом сравнении тип находящийся выше по дереву больче чем тип находящийся ниже по дереву, и наоборот: `parent > child`, `child < parent`, `ancestor > descendant`, `descendant < ancestor`.
### Ковариантность
Это механизм позволяющий использовать более конкретный тип там, где ранее предпологалось использовать менее конкр. тип. Иными словами, совместимыми считаются типы, ищеющие отношение `A > B` и `A = B`.  
Ковариативность не рекомендуется в местах допускающих запись. Рекомендуется использовать в местах допускающих чтение.
### Контрвариантность
Это противоположный ковариатности механизм позволяющий использовать менее конкретный тип, там где ранее предпологалось использовать более конкр. тип. Отношения: `A < B` и `A = B`. Не рекомендуется в местах допускающих чтение, и наоборот рекомендуется в местах допускающих запись.
### Инвариантность
Позволяет использ. только заданный тип. Совместимы только идентичные типы `A = A`.
### Бивариативность
Является предст. всех ранее перечисленных видов вариативности. Совместимыми считаются любые из ранее перечисленных типов `A > B`, `A < B` и `A = B`. Явл. самым небезопасным видом вариативности.

---
Синтаксические конструкции

---
## Аннотация типов
### Общее
TS это типизированная надстройка над JS. По этой причине TS не добавляет новых синтаксических конструкций в JS, за искл. `Enum`, а лишь расширяет его за счет добавления типов.
### Аннотация типа
Аннотация или указание типа осуществляется с помощью оператора двоеточия `:`, после которого следует идентификатор типа. После связывания идентификатора с типом, изменить тип нельзя.
### Var, Let, Const
Тип данных указывается сразу после идентификатора.
```javascript
var identifier: Type = value;
let identifier: Type = value;
const IDENTIFIER: Type = value;
```
### Функции (function)
```javascript
function identifier(param1: Type, param2: Type): ReturnedType {
}
```
Тип возвращаемого значения распологается между параметрами функции и её телом. При наличии параметров тип данных также указывается и для них.  
В TS в отличии от JS в сигнатуру функции помимо её имени и параметров также входит и возвращаемое значение.  
Также можно объявлять параметризированные функции, такие фукнкции будут называться обобщенными. Параметры типа заключаются в угловые скобки и распологаются перед круглыми скобками `()`.
```javascript
function identifier <T, U>(): ReturnedType {
}
```
В TS также сущ-ет механизм перегрузки функций. С помощью нее можно аннотировать функции с одинаковым идентификаторами, но с различными сигнатурами.  
Для этого перед определением функции, метода или функции-конструктора **перечисляются _совместимые объявления_** одних только сигнатур.
```javascript
function identifier(p1: T1, p2: T2): T3;
function identifier(p1: T4, p2: T5): T6;
function identifier(p1: T, p2: T): T {
  return 'value'
}

const a: T1 = 'value';
const b: T2 = 'value';
const c: T4 = 'value';
const d: T5 = 'value';

identifier(a, b); // валидно
identifier(c, d); // валидно
```
### Стрелочные функции (arrow function)
Применимы те же правила указания типов, что и для обычных фукнций, за искл. того возвращаемый тип указывается м/у параметрами и стрелкой.
```javascript
<T, U>(param: Type, param2: Type): Type => value;
```
### Классы (class)
Пир объявлении класса, как и в случае с переменными, тип данных указывается сразу после идентификатора (имени класса). Для методов класса действуют те же правила указания типов, что и для обычных фукнций.  
Для свойств, в частности для `get`, указывается тип данных возвращаемого значения. Для `set` указывается лишь тип единственного параметра, а тип возвращаемого значения, вообще запрещается указывать явно.  
В случае объявления обобщенного класса, параметры типа указываются сразу после идентификатора класса.
```javascript
class Identifier<T> {
 static staticField: Type = value; // член класса

 static get staticProperty(): Type { // член класса
   return value;
 }

 static set staticProperty(value: Type) { // член класса

 }

 static staticMethod <T, U>(param0: Type, param1: Type): Type { // член класса

 }
 [indexSignature: Type]: Type; // член класса

 [computedProp]: Type = value; // член класса

 field: Type = value; // член класса

 get property(): Type { // член класса
   return value;
 }
 set property(value: Type) { // член класса

 }

 constructor(param0: Type, param1: Type) {

 }

 method <T, U>(param0: Type, param1: Type): Type { // член класса

 }
}
```
### Итог
- Аннотация типа устанавливается оператором двоеточия `:`, после кот. следует указание типа данных.
- При объявлении переменных тип данных указывается сразу после идентификатора.
- У функций и методов класса возвращаемый тип данных указывается между параметрами и телом.
- У стрелочных функций меджду параметрами и стрелкой.
- У функций, стрелочных функций и методов класса тип данных также указывается и для параметров.
- При необходимости можно указать параметры типа в угловых скобках и разместить перед кругрыми скобками.
- В TS аннотирование типов у функций, методов и конструкторов расширено при помощи перегрузки функций.
- Для полей класса тип указывается сразу после идентификатора-имени.
- Для геттеров указывается возвращаемый тип данных.
- Для сеттеров указ. тип единственного параметра и вовсе не указывается возвращаемый тип.

---
Типы

---
## Базовый тип Any
